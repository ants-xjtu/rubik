In this article, I will go through the main concepts and features of Rubik. Some of them are overlapped to the content of the paper, but in a programmer's perspective rather than a designer.

Rubik is a parser generator, which means it takes a python module (normally a single file) as input (which is allowed to import reusable components provided by Rubik and others) and generates a huge C source file. The source file can further be compiled by GCC or Clang, and linked against the runtime library provided by Rubik and code contains custom middlebox functionalities provided by the user. As a user of Rubik, you still need to write some code in C to specify how you would like to treat payload data of e.g. TCP; Rubik does not have a super cow power to guess it out. However, you are free from extracting that payload data out of raw packets, since this task is taken care of by Rubik perfectly.

As the first view, I will introduce the executing model and order of Rubik, which is essential to learn how you can configure Rubik's behavior, where to put custom middleboxes, and what input those middleboxes are fed.

*TODO: executing diagram*

The parsing process of each packet is divided into several **layers**. One processing layer takes the responsibility of parsing one protocol layer of the packet. Since the input packets may belong to different protocols/protocol stacks, different layer sequences must be used for parsing different packets. To achieve that, all available layers are organized into a parsing tree, and one layer (usually Ethernet) is chosen as an entry point which handles all packets. After the parsing process of one layer, one successor layer of it must be selected to continue parsing the packet or if there's no successor than the packet is fully parsed. In the input Python module of Rubik (aka stack configure), three things mention above must be specified:
* which layers are involved
* how these layers are connected into a parsing tree
* what is the entry condition of each layer except the global entry point

It will be shown in detail how to write this configure in the following examples. Notes that Rubik allows many instances of the same parsing layer coexist in a stack configure, for example, to parse a network traffic mixing TCP and GTP streams, you may want to use two TCP layer instances: one for vanilla TCP packets which connect as `eth -> ip -> tcp`, and the other one for GTP-wrapped TCP streams which connects as `eth -> ip -> udp -> gtp -> ip2 -> tcp2` (the IP layer also initializes two instances in this example). The supporting to multiple initializations means that it must be between layer **prototype** and **instance**. The user should define the behavior of a layer as a layer prototype, and initialize as many instances as she wants modeling from that prototype. From now on the word "prototype" will be used to reference layer prototype and the "layer" is for layer instance.

Let's look more deeply into a layer. The parsing process inside a layer is divided into six stages (which is not pipelined in executing). The stages are linearly executed and there's no loop so every layer spends a fixed time to process a packet. The stages are named:
* header: parse the content of the packet and read from necessary header fields
* instance: find stream instance that the current packet belongs to in a layer-owned hashtable
* preparation: assign to variables which would be used in the following stages
* sequence: maintain a reorder buffer for the current stream
* PSM (protocol state machine): maintain a state machine for the current stream
* event: user-defined custom code

The first thing to notice is that most of the stages are optional. For the simplest layer only the header stage is required (which will be shown in the demo later). The instance stage must exist if you want to use sequence and PSM stages, or declare instance variables (which is covered later). Some stages also provide useful built-in variables, and you must include those stages if you want to use the variables.

The second thing is about implementation details. Rubik introduces an IR (immediate representation) and an optimizer works on it, which helps Rubik to output high-performance C code which may reorder stages and operations and remove unnecessary ones. As a result, the 6-stage model is only logically ensured for providing a stable programming interface to the user, for example, knowing that the event stage is always after the PSM stage lets the user infers that custom code in the event stage will always access to state machine's current state which is already modified by current packet, and for the similar reason configure in the preparation stage will always access to the "previous" state of the state machine which is still not modified by the current packet. While gaining an easier-to-use programming model thanks to the logical executing model, the user also should not worry about performance and keep all logic in the stage that most suitable to it and let the optimizer to handle the rest.

In a word, when a packet is incoming, Rubik runtime puts it into a parsing layer, executes some of the six stages, then selects another proper parsing layer according to some conditions and executes the stages of it, and does this again and again until the last layer is finished. Normally user could execute arbitrary custom code at the end of each layer that the packet goes through, which means the user has multiple chances to insert their code, one time for one layer (and for one protocol layer). Each layer can access all variables of all previous-executed layers, for example, you could still get the IP pair of a packet even in the event stage of the TCP layer.

In the rest part of this article, I will show you how to write a layer prototype, starts from the simplest nop prototype, and ends in a fully-functional one that generally involved every feature of Rubik. And finally, I will initialize an instance in a TCP/IP stack configure.